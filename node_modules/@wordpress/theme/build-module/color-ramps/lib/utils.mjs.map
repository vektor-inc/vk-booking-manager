{
  "version": 3,
  "sources": ["../../../src/color-ramps/lib/utils.ts"],
  "sourcesContent": ["/**\n * External dependencies\n */\nimport { type ColorTypes } from 'colorjs.io/fn';\n\n/**\n * Internal dependencies\n */\nimport './register-color-spaces';\nimport {\n\tWHITE,\n\tBLACK,\n\tUNIVERSAL_CONTRAST_TOPUP,\n\tWHITE_TEXT_CONTRAST_MARGIN,\n\tACCENT_SCALE_BASE_LIGHTNESS_THRESHOLDS,\n\tMAX_BISECTION_ITERATIONS,\n\tCONTRAST_EPSILON,\n} from './constants';\nimport type { Ramp, RampConfig, RampDirection } from './types';\nimport { getContrast } from './color-utils';\n\n/**\n * Build a dependency graph from the steps configuration\n * @param config - The steps configuration object\n */\nfunction buildDependencyGraph( config: RampConfig ): {\n\tdependencies: Map< keyof Ramp, ( keyof Ramp | 'seed' )[] >;\n\tdependents: Map< keyof Ramp | 'seed', ( keyof Ramp )[] >;\n} {\n\tconst dependencies = new Map< keyof Ramp, ( keyof Ramp | 'seed' )[] >();\n\tconst dependents = new Map< keyof Ramp | 'seed', ( keyof Ramp )[] >();\n\n\t// Initialize maps\n\tObject.keys( config ).forEach( ( step ) => {\n\t\tdependencies.set( step as keyof Ramp, [] );\n\t} );\n\tdependents.set( 'seed', [] );\n\tObject.keys( config ).forEach( ( step ) => {\n\t\tdependents.set( step as keyof Ramp, [] );\n\t} );\n\n\t// Build the graph\n\tObject.entries( config ).forEach( ( [ stepName, stepConfig ] ) => {\n\t\tconst step = stepName as keyof Ramp;\n\t\tconst reference = stepConfig.contrast.reference;\n\n\t\tdependencies.get( step )!.push( reference );\n\t\tdependents.get( reference )!.push( step );\n\n\t\t// Add dependency for sameAsIfPossible\n\t\tif ( stepConfig.sameAsIfPossible ) {\n\t\t\tdependencies.get( step )!.push( stepConfig.sameAsIfPossible );\n\t\t\tdependents.get( stepConfig.sameAsIfPossible )!.push( step );\n\t\t}\n\t} );\n\n\treturn { dependencies, dependents };\n}\n\n/**\n * Topologically sort steps based on their dependencies\n * @param config - The steps configuration object\n */\nexport function sortByDependency( config: RampConfig ): ( keyof Ramp )[] {\n\tconst { dependents } = buildDependencyGraph( config );\n\tconst result: ( keyof Ramp )[] = [];\n\tconst visited = new Set< keyof Ramp | 'seed' >();\n\tconst visiting = new Set< keyof Ramp | 'seed' >();\n\n\tfunction visit( node: keyof Ramp | 'seed' ): void {\n\t\tif ( visiting.has( node ) ) {\n\t\t\tthrow new Error(\n\t\t\t\t`Circular dependency detected involving step: ${ String(\n\t\t\t\t\tnode\n\t\t\t\t) }`\n\t\t\t);\n\t\t}\n\t\tif ( visited.has( node ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvisiting.add( node );\n\n\t\t// Visit all dependents (steps that depend on this node)\n\t\tconst nodeDependents = dependents.get( node ) || [];\n\t\tnodeDependents.forEach( ( dependent ) => {\n\t\t\tvisit( dependent );\n\t\t} );\n\n\t\tvisiting.delete( node );\n\t\tvisited.add( node );\n\n\t\t// Add to result only if it's a step (not 'seed')\n\t\tif ( node !== 'seed' ) {\n\t\t\tresult.unshift( node ); // Add to front for correct topological order\n\t\t}\n\t}\n\n\t// Start with seed - this will recursively visit all reachable nodes\n\tvisit( 'seed' );\n\n\treturn result;\n}\n/**\n * Return minimal set of steps that are needed to calculate `stepName` from the seed.\n * @param stepName Name of the step.\n * @param config   Configuration of the ramp.\n * @return Array of steps that `stepName` depends on.\n */\nexport function stepsForStep(\n\tstepName: keyof Ramp,\n\tconfig: RampConfig\n): ( keyof Ramp )[] {\n\tconst result = new Set< keyof Ramp >();\n\tfunction visit( step: keyof Ramp | 'seed' ) {\n\t\tif ( step === 'seed' || result.has( step ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst stepConfig = config[ step ];\n\t\tif ( ! stepConfig ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvisit( stepConfig.contrast.reference );\n\t\tif ( stepConfig.sameAsIfPossible ) {\n\t\t\tvisit( stepConfig.sameAsIfPossible );\n\t\t}\n\n\t\tresult.add( step );\n\t}\n\tvisit( stepName );\n\treturn Array.from( result );\n}\n\n/**\n * Finds out whether a lighter or a darker foreground color achieves a better\n * contrast against the seed\n * @param seed\n * @param preferLighter Whether the check should favor white foreground color\n * @return An object with \"better\" and \"worse\" properties, each holding a\n * ramp direction value.\n */\nexport function computeBetterFgColorDirection(\n\tseed: ColorTypes,\n\tpreferLighter?: boolean\n): {\n\tbetter: RampDirection;\n\tworse: RampDirection;\n} {\n\tconst contrastAgainstBlack = getContrast( seed, BLACK );\n\tconst contrastAgainstWhite = getContrast( seed, WHITE );\n\n\treturn contrastAgainstBlack >\n\t\tcontrastAgainstWhite +\n\t\t\t( preferLighter ? WHITE_TEXT_CONTRAST_MARGIN : 0 )\n\t\t? { better: 'darker', worse: 'lighter' }\n\t\t: { better: 'lighter', worse: 'darker' };\n}\n\nexport function adjustContrastTarget( target: number ) {\n\tif ( target === 1 ) {\n\t\treturn 1;\n\t}\n\n\t// Add a little top up to take into account any rounding error and algo imprecisions.\n\treturn target + UNIVERSAL_CONTRAST_TOPUP;\n}\n\n/**\n * Prevent the accent scale from referencing a lightness value that\n * would prevent the algorithm from complying with the requirements\n * and cause it to generate unexpected results.\n * @param rawLightness\n * @param direction\n * @return The clamped lightness value\n */\nexport function clampAccentScaleReferenceLightness(\n\trawLightness: number,\n\tdirection: RampDirection\n) {\n\tconst thresholds = ACCENT_SCALE_BASE_LIGHTNESS_THRESHOLDS[ direction ];\n\treturn Math.max( thresholds.min, Math.min( thresholds.max, rawLightness ) );\n}\n\n/**\n * Find the value of of `L` (luminance) that produces a `C` (color) that has a\n * `value` (contrast delta) equal to zero.\n * @param calculateC     Calculate `C` from a given `L`.\n * @param calculateValue Calculate value (delta) for a given `C`.\n * @param initLowerL     Initial lower value of `L`.\n * @param initLowerValue Initial lower delta (negative).\n * @param initUpperL     Initial upper value of `L`.\n * @param initUpperValue Initial upper delta (positive).\n * @return Resulting value of type `C`.\n */\nexport function solveWithBisect< C >(\n\tcalculateC: ( l: number ) => C,\n\tcalculateValue: ( t: C ) => number,\n\tinitLowerL: number,\n\tinitLowerValue: number,\n\tinitUpperL: number,\n\tinitUpperValue: number\n): C {\n\tlet lowerL = initLowerL;\n\tlet lowerValue = initLowerValue;\n\tlet lowerReplaced = false;\n\n\tlet upperL = initUpperL;\n\tlet upperValue = initUpperValue;\n\tlet upperReplaced = false;\n\n\tlet bestC: C;\n\tlet bestValue: number;\n\tlet iterations = 0;\n\n\twhile ( true ) {\n\t\titerations++;\n\n\t\t// Linear interpolation: find the point where a line would cross the zero axis.\n\t\tconst newL =\n\t\t\t( lowerL * upperValue - upperL * lowerValue ) /\n\t\t\t( upperValue - lowerValue );\n\n\t\tbestC = calculateC( newL );\n\t\tbestValue = calculateValue( bestC );\n\n\t\tif (\n\t\t\tMath.abs( bestValue ) <= CONTRAST_EPSILON ||\n\t\t\titerations >= MAX_BISECTION_ITERATIONS\n\t\t) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Update the lower/upper bracket values. When only one side is repeatedly updated,\n\t\t// apply so-called \"Illinois trick\" for faster convergence: halve the opposite value.\n\t\tif ( bestValue <= 0 ) {\n\t\t\tlowerL = newL;\n\t\t\tlowerValue = bestValue;\n\t\t\tif ( lowerReplaced ) {\n\t\t\t\tupperValue /= 2;\n\t\t\t}\n\t\t\tlowerReplaced = true;\n\t\t\tupperReplaced = false;\n\t\t} else {\n\t\t\tupperL = newL;\n\t\t\tupperValue = bestValue;\n\t\t\tif ( upperReplaced ) {\n\t\t\t\tlowerValue /= 2;\n\t\t\t}\n\t\t\tupperReplaced = true;\n\t\t\tlowerReplaced = false;\n\t\t}\n\t}\n\n\treturn bestC;\n}\n"],
  "mappings": "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",
  "names": []
}
