{
  "version": 3,
  "sources": ["../../../src/color-ramps/lib/taper-chroma.ts"],
  "sourcesContent": ["/**\n * External dependencies\n */\nimport {\n\tget,\n\ttoGamut,\n\tOKLCH,\n\tsRGB,\n\ttype PlainColorObject,\n\ttype ColorSpace,\n} from 'colorjs.io/fn';\n\n/**\n * Internal dependencies\n */\nimport './register-color-spaces';\n\nexport interface TaperChromaOptions {\n\tgamut?: ColorSpace; // target gamut (default `sRGB`)\n\talpha?: number; // base fraction of Cmax at target (default 0.62)\n\tcarry?: number; // seed vividness carry exponent \u03B2 in [0..1] (default 0.5)\n\tcUpperBound?: number; // hard search cap for C (default 0.45)\n\t// Continuous taper around the seed (desaturate both sides slightly)\n\tradiusLight?: number; // distance in L where kLight is reached (default 0.20)\n\tradiusDark?: number; // distance in L where kDark is reached (default 0.20)\n\tkLight?: number; // floor multiplier near lighter side (default 0.85)\n\tkDark?: number; // floor multiplier near darker side (default 0.85)\n\t// Achromatic handling\n\thueFallback?: number; // degrees: if seed is achromatic and you still want color\n\tachromaEpsilon?: number; // \u2264 this chroma \u2192 treat as achromatic (default 0.005)\n}\n\n/**\n * Given the seed and the target lightness, tapers the chroma smoothly.\n * - C_intended = Cmax(Lt,H0) * alpha * (seedRelative^carry)\n * - Continuous taper vs |Lt - Ls| to softly reduce chroma for neighbors\n * - Downward-only clamp on C (preserve L & H)\n * @param seed\n * @param lTarget\n * @param options\n */\nexport function taperChroma(\n\tseed: PlainColorObject, // already OKLCH\n\tlTarget: number, // [0..1]\n\toptions: TaperChromaOptions = {}\n): { l: number; c: number } | PlainColorObject {\n\tconst gamut = options.gamut ?? sRGB;\n\tconst alpha = options.alpha ?? 0.65; // 0.7-0.8 works well for accent surface\n\tconst carry = options.carry ?? 0.5;\n\tconst cUpperBound = options.cUpperBound ?? 0.45;\n\tconst radiusLight = options.radiusLight ?? 0.2;\n\tconst radiusDark = options.radiusDark ?? 0.2;\n\tconst kLight = options.kLight ?? 0.85;\n\tconst kDark = options.kDark ?? 0.85;\n\tconst achromaEpsilon = options.achromaEpsilon ?? 0.005;\n\n\tconst cSeed = Math.max( 0, get( seed, [ OKLCH, 'c' ] ) );\n\tlet hSeed = get( seed, [ OKLCH, 'h' ] );\n\n\tconst chromaIsTiny = cSeed < achromaEpsilon;\n\tconst hueIsInvalid = hSeed === null || ! Number.isFinite( hSeed );\n\n\tif ( chromaIsTiny || hueIsInvalid ) {\n\t\tif ( typeof options.hueFallback === 'number' ) {\n\t\t\thSeed = normalizeHue( options.hueFallback );\n\t\t} else {\n\t\t\t// Respect achromatic intent: grayscale at target L\n\t\t\treturn {\n\t\t\t\tspace: OKLCH,\n\t\t\t\tcoords: [ clamp01( lTarget ), 0, 0 ],\n\t\t\t\talpha: 1,\n\t\t\t};\n\t\t}\n\t}\n\n\t// Capacity at seed and target\n\tconst lSeed = clamp01( get( seed, [ OKLCH, 'l' ] ) );\n\tconst cmaxSeed = getCachedMaxChromaAtLH( lSeed, hSeed, gamut, cUpperBound );\n\tconst cmaxTarget = getCachedMaxChromaAtLH(\n\t\tclamp01( lTarget ),\n\t\thSeed,\n\t\tgamut,\n\t\tcUpperBound\n\t);\n\n\t// Seed vividness ratio (hue-fair normalization)\n\tlet seedRelative = 0;\n\tconst denom = cmaxSeed > 0 ? cmaxSeed : 1e-6;\n\tseedRelative = clamp01( cSeed / denom );\n\n\t// Intended chroma from local capacity, tempered by seed vividness\n\tconst cIntendedBase = alpha * cmaxTarget;\n\tconst cWithCarry =\n\t\tcIntendedBase * Math.pow( seedRelative, clamp01( carry ) );\n\n\t// Gentle, symmetric desaturation vs distance in L\n\tconst t = continuousTaper( lSeed, lTarget, {\n\t\tradiusLight,\n\t\tradiusDark,\n\t\tkLight,\n\t\tkDark,\n\t} );\n\tconst cPlanned = cWithCarry * t;\n\n\t// Downward-only clamp (preserve L & H)\n\tconst lOut = clamp01( lTarget );\n\n\treturn { l: lOut, c: cPlanned };\n}\n\n/* ---------------- helpers & caches ---------------- */\n\nfunction clamp01( x: number ): number {\n\tif ( x < 0 ) {\n\t\treturn 0;\n\t}\n\tif ( x > 1 ) {\n\t\treturn 1;\n\t}\n\treturn x;\n}\nfunction normalizeHue( h: number ): number {\n\tlet hue = h % 360;\n\tif ( hue < 0 ) {\n\t\thue += 360;\n\t}\n\treturn hue;\n}\nfunction raisedCosine( u: number ): number {\n\tconst x = clamp01( u );\n\treturn 0.5 - 0.5 * Math.cos( Math.PI * x );\n}\n\n/**\n * smooth, distance-from-seed chroma taper (raised-cosine per side)\n * @param seedL\n * @param targetL\n * @param opts\n * @param opts.radiusLight\n * @param opts.radiusDark\n * @param opts.kLight\n * @param opts.kDark\n */\nfunction continuousTaper(\n\tseedL: number,\n\ttargetL: number,\n\topts: {\n\t\tradiusLight: number;\n\t\tradiusDark: number;\n\t\tkLight: number;\n\t\tkDark: number;\n\t}\n): number {\n\tconst d = targetL - seedL;\n\tif ( d >= 0 ) {\n\t\tconst u = opts.radiusLight > 0 ? Math.abs( d ) / opts.radiusLight : 1;\n\t\tconst w = raisedCosine( u > 1 ? 1 : u );\n\t\treturn 1 - ( 1 - opts.kLight ) * w;\n\t}\n\tconst u = opts.radiusDark > 0 ? Math.abs( d ) / opts.radiusDark : 1;\n\tconst w = raisedCosine( u > 1 ? 1 : u );\n\treturn 1 - ( 1 - opts.kDark ) * w;\n}\n\n/* ---- chroma-capacity queries with small caches ---- */\n\nconst maxChromaCache = new Map< string, number >();\nfunction keyMax( l: number, h: number, gamut: string, cap: number ): string {\n\t// Quantize to keep cache compact\n\tconst lq = quantize( l, 0.05 );\n\tconst hq = quantize( normalizeHue( h ), 10 );\n\tconst cq = quantize( cap, 0.05 );\n\treturn `${ gamut }|L:${ lq }|H:${ hq }|cap:${ cq }`;\n}\n\nfunction quantize( x: number, step: number ): number {\n\tconst k = Math.round( x / step );\n\treturn k * step;\n}\n\nfunction getCachedMaxChromaAtLH(\n\tl: number,\n\th: number,\n\tgamutSpace: ColorSpace,\n\tcap: number\n): number {\n\tconst gamut = gamutSpace.id;\n\tconst key = keyMax( l, h, gamut, cap );\n\tconst hit = maxChromaCache.get( key );\n\tif ( typeof hit === 'number' ) {\n\t\treturn hit;\n\t}\n\n\tconst computed = maxInGamutChromaAtLH( l, h, gamutSpace, cap );\n\tmaxChromaCache.set( key, computed );\n\treturn computed;\n}\n\n/**\n * Find the max in-gamut chroma at fixed (L,H) in the target gamut\n * @param l\n * @param h\n * @param gamutSpace\n * @param cap\n */\nfunction maxInGamutChromaAtLH(\n\tl: number,\n\th: number,\n\tgamutSpace: ColorSpace,\n\tcap: number\n): number {\n\t// Construct a color with maximum chroma.\n\tconst probe: PlainColorObject = {\n\t\tspace: OKLCH,\n\t\tcoords: [ l, cap, h ],\n\t\talpha: 1,\n\t};\n\n\t// Let `toGamut` reduce the chroma to the gamut maximum.\n\tconst clamped = toGamut( probe, { space: gamutSpace, method: 'css' } );\n\n\treturn get( clamped, [ OKLCH, 'c' ] );\n}\n"],
  "mappings": "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",
  "names": ["u", "w"]
}
