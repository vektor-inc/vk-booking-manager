/**
 * External dependencies
 */
import { get, OKLCH } from 'colorjs.io/fn';

/**
 * Internal dependencies
 */
import './lib/register-color-spaces';
import { buildRamp } from './lib/index';
import { clampAccentScaleReferenceLightness } from './lib/utils';
import { BG_RAMP_CONFIG, ACCENT_RAMP_CONFIG } from './lib/ramp-configs';
import type {
	RampResult as InternalRampResult,
	RampDirection,
	Ramp,
} from './lib/types';
import { getContrast } from './lib/color-utils';
import { CONTRAST_COMBINATIONS } from './lib/constants';
export { DEFAULT_SEED_COLORS } from './lib/constants';

/**
 * Creates a background ramp.
 * @param seed The seed color for the background ramp.
 */
export function buildBgRamp( seed: string ) {
	if ( typeof seed !== 'string' || seed.trim() === '' ) {
		throw new Error( 'Seed color must be a non-empty string' );
	}

	return buildRamp( seed, BG_RAMP_CONFIG );
}

const STEP_TO_PIN = 'surface2';
function getBgRampInfo( ramp: InternalRampResult ): {
	mainDirection: RampDirection;
	pinLightness: {
		stepName: keyof Ramp;
		value: number;
	};
} {
	return {
		mainDirection: ramp.direction,
		pinLightness: {
			stepName: STEP_TO_PIN,
			value: clampAccentScaleReferenceLightness(
				get( ramp.ramp[ STEP_TO_PIN ], [ OKLCH, 'l' ] ),
				ramp.direction
			),
		},
	};
}

/**
 * Creates an accent ramp (ie used by primary, success, info, warning and error
 * ramps).
 * @param seed   The seed color for the accent ramp.
 * @param bgRamp The ramp of the background on which the accent is shown.
 */
export function buildAccentRamp(
	seed: string,
	bgRamp?: InternalRampResult
): InternalRampResult {
	if ( typeof seed !== 'string' || seed.trim() === '' ) {
		throw new Error( 'Seed color must be a non-empty string' );
	}

	const bgRampInfo = bgRamp ? getBgRampInfo( bgRamp ) : undefined;
	return buildRamp( seed, ACCENT_RAMP_CONFIG, bgRampInfo );
}

/**
 * Checks that all bg/fg combinations generated by the ramps meet contrast
 * targets.
 * @param params
 * @param params.bgRamp
 * @param params.accentRamps
 */
export function checkAccessibleCombinations( {
	bgRamp,
	accentRamps = [],
}: {
	bgRamp: InternalRampResult;
	accentRamps?: InternalRampResult[];
} ) {
	const unmetTargets: {
		bgName: keyof Ramp;
		bgColor: string;
		fgName: keyof Ramp;
		fgColor: string;
		unmetContrast: number;
		achievedContrast: number;
	}[] = [];

	// Assess combinations within each ramp
	[ bgRamp, ...accentRamps ].forEach( ( ramp ) => {
		CONTRAST_COMBINATIONS.forEach( ( { bgs, fgs, target } ) => {
			for ( const bg of bgs ) {
				for ( const fg of fgs ) {
					const bgColor = ramp.ramp[ bg ];
					const fgColor = ramp.ramp[ fg ];
					const achievedContrast = getContrast( bgColor, fgColor );
					if ( achievedContrast < target ) {
						unmetTargets.push( {
							bgName: bg,
							bgColor,
							fgName: fg,
							fgColor,
							unmetContrast: target,
							achievedContrast,
						} );
					}
				}
			}
		} );
	} );
	// Assess each accent ramp's fg color against bg ramp
	accentRamps.forEach( ( ramp ) => {
		CONTRAST_COMBINATIONS.forEach( ( { bgs, fgs, target } ) => {
			for ( const bg of bgs ) {
				for ( const fg of fgs ) {
					const bgColor = bgRamp.ramp[ bg ];
					const fgColor = ramp.ramp[ fg ];
					const achievedContrast = getContrast( bgColor, fgColor );
					if ( achievedContrast < target ) {
						unmetTargets.push( {
							bgName: bg,
							bgColor,
							fgName: fg,
							fgColor,
							unmetContrast: target,
							achievedContrast,
						} );
					}
				}
			}
		} );
	} );

	return unmetTargets;
}

export type RampResult = InternalRampResult;
